# Instructions for Claude (AI Assistant)

This file contains guidance for Claude Code or other AI assistants working on this project.

## Project Overview

This is a **Z80/i8080 CPU emulator** written in ABAP, designed to run CP/M programs. The code is transpiler-compatible, allowing local testing via Node.js.

## Quick Start for AI Assistants

### 1. Read These Files First

**Priority order:**
1. **CONTEXT.md** - Current project status, architecture decisions, what's working
2. **TODO.md** - Implementation plan, missing opcodes, test strategy
3. **BRAINSTORM.md** - Architecture analysis (why hybrid approach was chosen)
4. **TRANSPILER.md** - ABAP transpiler constraints and workarounds

### 2. Current Working State

```bash
# Run tests locally (< 1 second)
npm test

# Expected output: 16 tests passing
# Status: 86/105 i8080 opcodes implemented (82%)
```

**Files to edit:**
- `src/zcl_cpu_8080_v2.clas.abap` - Main CPU emulator (1,716 lines)
- `src/zcl_cpu_8080_v2.clas.testclasses.abap` - Unit tests (459 lines)

**Files NOT to edit:**
- `output/*` - Auto-generated by transpiler
- `node_modules/*` - npm packages

### 3. Testing Workflow

```bash
# After making changes:
npm test                    # Transpile + run tests
git status                  # Check what changed
git add src/*.abap          # Stage changes
git commit -m "Message"     # Commit
git push                    # Push to GitHub
```

## Architecture Constraints

### ABAP Transpiler Compatibility

**These patterns work:**
```abap
" ✓ STRING operations (memory representation)
DATA: mv_memory TYPE string.
lv_hex = mv_memory+lv_offset(2).

" ✓ Arithmetic instead of bit operations
lv_high = lv_val DIV 256.
lv_low = lv_val MOD 256.

" ✓ DO loops with sy-index
DO 256 TIMES.
  lv_val = sy-index - 1.
ENDDO.
```

**These patterns DON'T work:**
```abap
" ✗ Internal table APPEND
APPEND lv_val TO mt_table.  " Use STRING concatenation instead

" ✗ BIT operations on integers
lv_result = lv_val BIT-AND 255.  " Use MOD/DIV instead

" ✗ XSTRING operations
DATA: mv_mem TYPE xstring.  " Use STRING instead
```

### Memory Representation

**Important:** Memory is stored as STRING with 2 hex chars per byte:
```abap
" 64KB memory = 131,072 hex characters
mv_memory = '00414243...'  " Each byte is 2 hex digits

" Read byte at address 0x1000:
lv_offset = 4096 * 2.          " Address × 2
lv_hex = mv_memory+8192(2).    " Extract 2 chars
rv_val = hex_to_byte( lv_hex ). " Convert to integer

" Write byte:
lv_hex = byte_to_hex( lv_val ).
mv_memory = lv_before && lv_hex && lv_after.
```

## Code Style Guidelines

### Dual i8080/Z80 Naming

**Always document both architectures in comments:**
```abap
WHEN 1.   " LD BC,nnnn (Z80) / LXI B (i8080)
WHEN 6.   " LD B,nn (Z80) / MVI B,nn (i8080)
WHEN 195. " JP nnnn (Z80) / JMP nnnn (i8080)
```

### Opcode Implementation Pattern

**For individual opcodes:**
```abap
WHEN 9.  " ADD HL,BC (Z80) / DAD B (i8080)
  " Implementation here
  rv_cycles = 11.
```

**For opcode families (use bit arithmetic):**
```abap
WHEN OTHERS.
  IF iv_opcode >= 128 AND iv_opcode <= 191.
    " ALU operations family
    lv_op = ( iv_opcode - 128 ) DIV 8.   " Operation type (0-7)
    lv_reg = ( iv_opcode - 128 ) MOD 8.  " Register ID (0-7)
```

### Test Structure

**Each opcode should have a test:**
```abap
METHOD test_add_hl_bc.
  " Test ADD HL,BC instruction
  mo_cpu->reset( ).

  " Program: LD HL,0x1000; LD BC,0x0234; ADD HL,BC; HALT
  mo_cpu->write_byte( iv_addr = 256 iv_val = 33 ).   " LD HL,nnnn
  mo_cpu->write_byte( iv_addr = 257 iv_val = 0 ).
  mo_cpu->write_byte( iv_addr = 258 iv_val = 16 ).   " 0x1000
  mo_cpu->write_byte( iv_addr = 259 iv_val = 1 ).    " LD BC,nnnn
  mo_cpu->write_byte( iv_addr = 260 iv_val = 52 ).
  mo_cpu->write_byte( iv_addr = 261 iv_val = 2 ).    " 0x0234
  mo_cpu->write_byte( iv_addr = 262 iv_val = 9 ).    " ADD HL,BC
  mo_cpu->write_byte( iv_addr = 263 iv_val = 118 ).  " HALT

  mo_cpu->execute_until_halt( ).

  DATA(lv_hl) = mo_cpu->get_hl( ).
  cl_abap_unit_assert=>assert_equals(
    act = lv_hl
    exp = 4660  " 0x1000 + 0x0234 = 0x1234
    msg = 'ADD HL,BC should compute 0x1000 + 0x0234 = 0x1234' ).
ENDMETHOD.
```

## Common Tasks

### Adding a New Opcode

1. **Find the opcode value** (see TODO.md or i8080 opcode table)
2. **Add to execute_opcode method:**
   ```abap
   WHEN 9.  " ADD HL,BC (Z80) / DAD B (i8080)
     DATA: lv_result TYPE i.
     lv_result = ( mv_hl + mv_bc ) MOD 65536.

     " Set carry flag if overflow
     IF ( mv_hl + mv_bc ) >= 65536.
       " Set C flag...
     ENDIF.

     mv_hl = lv_result.
     rv_cycles = 11.
   ```
3. **Write a test** (see pattern above)
4. **Run tests:** `npm test`
5. **Verify all pass**

### Debugging Failed Tests

1. **Check transpiler output:**
   ```bash
   npm test 2>&1 | grep -A 10 "Error"
   ```

2. **Add debug output:**
   ```abap
   " Temporary debug (remove before commit)
   WRITE: / 'PC:', mv_pc, 'HL:', mv_hl.
   ```

3. **Isolate the issue:**
   - Create minimal test case
   - Check expected vs actual values
   - Verify opcode encoding

### Working with Flags

**Flag bits (same as Z80):**
```abap
c_flag_c = 1    " Carry
c_flag_n = 2    " Add/Subtract (BCD)
c_flag_p = 4    " Parity/Overflow
c_flag_h = 16   " Half-carry
c_flag_z = 64   " Zero
c_flag_s = 128  " Sign
```

**Setting flags:**
```abap
lv_flags = get_flags_byte( ).

" Set carry flag
IF overflow.
  lv_flags = lv_flags + 1 - ( lv_flags MOD 2 ).  " Set bit 0
ENDIF.

" Clear carry flag
lv_flags = lv_flags - ( lv_flags MOD 2 ).

set_flags_byte( lv_flags ).
```

## What NOT to Do

❌ **Don't change memory representation** - It's optimized for transpiler
❌ **Don't use BIT operations** - Use arithmetic (DIV/MOD) instead
❌ **Don't use internal tables** - Use STRING concatenation
❌ **Don't skip tests** - Every opcode needs a test
❌ **Don't break existing tests** - Run `npm test` before committing
❌ **Don't modify output/* files** - They're auto-generated

## Current Implementation Status

See **TODO.md** for detailed list, but quick summary:

**✅ Implemented (86 opcodes):**
- All LD/MOV operations
- All ALU operations (ADD, SUB, AND, OR, XOR, CP)
- All conditional jumps/calls/returns
- Stack operations (PUSH, POP)
- Rotate operations (RLCA, RRCA, RLA, RRA)

**⏳ Missing (19 opcodes):**
- ADD HL,rr (4 opcodes) - **HIGH PRIORITY**
- Exchange operations (4 opcodes) - **HIGH PRIORITY**
- RST instructions (8 opcodes)
- I/O operations (2 opcodes)
- Interrupt control (2 opcodes)

## Next Steps (From TODO.md)

**Recommended approach:**
1. Implement ADD HL,rr family (4 opcodes)
2. Implement exchange operations (4 opcodes)
3. Implement DI/EI as NOPs (2 opcodes)
4. Implement RST instructions (8 opcodes)
5. Add I/O stubs (2 opcodes)
6. Download and run 8080 Exerciser test suite
7. Fix any failures
8. Move to BDOS emulation

**Estimated time:** 4-6 hours for complete i8080

## Questions to Ask the User

Before implementing major changes, ask:

1. **"Which opcodes should I implement first?"**
   - High-priority vs complete implementation

2. **"Should I download the 8080 Exerciser test suite?"**
   - Industry standard validation

3. **"Do you want BDOS emulation next or complete i8080 first?"**
   - Affects implementation order

## Useful Commands

```bash
# Run tests
npm test

# Check file sizes
wc -l src/*.abap

# Show recent commits
git log --oneline -5

# Show current changes
git diff

# Count implemented opcodes (rough estimate)
grep "WHEN [0-9]" src/zcl_cpu_8080_v2.clas.abap | wc -l
```

## Resources Quick Links

- i8080 Opcode Reference: http://www.emulator101.com/reference/8080-by-opcode.html
- i8080 Opcode Table: https://pastraiser.com/cpu/i8080/i8080_opcodes.html
- Test Suite: http://www.retroarchive.org/cpm/cdrom/SIMTEL/CPMUG/ (8080EXM.COM)
- ABAP Transpiler: https://github.com/abaplint/transpiler

## Session Context

Always check these before starting:

1. **CONTEXT.md** - What was done in previous sessions
2. **TODO.md** - What needs to be done
3. **Git status** - `git log --oneline -3`
4. **Test status** - `npm test`

This ensures continuity across sessions and prevents redoing work.

---

*Last updated: 2025-10-19*
*For project history, see CONTEXT.md*
*For implementation plan, see TODO.md*
